import builder.html
import markdown.html.Filter
import std.set.Set
import syntax.Languages
import syntax.format.Html

class pub SyntaxHighlight {
  let @languages: Languages

  fn pub static new -> SyntaxHighlight {
    SyntaxHighlight { @languages = Languages.new }
  }

  fn mut highlight(pre: ref html.Element) -> Option[html.Element] {
    let code = match pre.nodes.opt(0) {
      case Some(Element(el)) if el.name == 'code' and el.nodes.size == 1 -> el
      case _ -> return Option.None
    }

    let lang = try code
      .attributes
      .opt('data-language')
      .then(fn (v) { @languages.get(v) })

    let bytes = match code.nodes.opt(0) {
      case Some(Text(v)) -> v.to_byte_array
      case _ -> return Option.None
    }

    match Html.new.format(lang.lexer(bytes)) {
      case { @nodes = nodes } -> match nodes.pop {
        case Some(Element(el)) -> Option.Some(el)
        case _ -> Option.None
      }
    }
  }

  fn mut replace(node: mut html.Node) {
    let el = match node {
      case Element(el) if el.name == 'pre' and el.nodes.size == 1 -> el
      case _ -> return
    }

    # We modify the `pre` element in-place, as swapping it with the new element
    # results in dropping of the old element while references (as part of the
    # iteration) to it still exist.
    match highlight(el) {
      case Some({ @name = name, @attributes = attr, @nodes = nodes }) -> {
        el.name = name
        el.attributes = attr
        el.nodes = nodes
      }
      case _ -> {}
    }
  }
}

impl Filter for SyntaxHighlight {
  fn pub mut run(document: mut html.Document) {
    document.nodes.iter_mut.each_with_index fn (idx, node) { replace(node) }
  }
}

class pub Admonitions {
  # The admonition classes that are supported.
  let pub @types: Set[String]

  # The base class to apply to the container.
  let pub @class: String

  # The element name to use for the icon.
  let pub @icon_element: String

  # The class to apply to the icon element.
  let pub @icon_class: String

  # The name of the class to apply to the text div.
  let pub @text_class: String

  fn pub static new -> Admonitions {
    let types = Set.new

    types.insert('info')
    types.insert('tip')
    types.insert('note')
    types.insert('warn')
    types.insert('discuss')

    Admonitions {
      @types = types,
      @class = 'admonition',
      @icon_element = 'i',
      @icon_class = 'icon',
      @text_class = 'text',
    }
  }

  fn replace(node: mut html.Node) {
    let note = match node {
      case Element(el) if el.name == 'div' -> el
      case _ -> return
    }

    let kind = match note.attributes.opt('class') {
      case Some(v) if @types.contains?(v) -> v
      case _ -> return
    }

    let nodes = note.take_nodes
    let icon = note.element(@icon_element)
    let text = note.element('div')

    note.attr('class', "{@class} {kind}")
    icon.attr('class', @icon_class)
    text.attr('class', @text_class)
    text.nodes = nodes
  }
}

impl Filter for Admonitions {
  fn pub mut run(document: mut html.Document) {
    document.nodes.iter_mut.each fn (node) { replace(node) }
  }
}
