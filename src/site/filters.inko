import builder.html (Document)
import markdown.html (Filter)

type DeletedText {}

impl Filter for DeletedText {
  fn pub mut run(document: mut Document) {
    let nodes = document.nodes.iter_mut.to_array

    loop {
      match nodes.pop {
        case Some(Element(el)) -> {
          match el.attributes.get('class') {
            case Ok('del') if el.name == 'span' -> {
              el.attributes = Map.new
              el.name = 'del'
            }
            case _ -> {}
          }

          nodes.append(el.nodes.iter_mut.to_array)
        }
        case Some(_) -> {}
        case _ -> break
      }
    }
  }
}

type Videos {
  fn static new -> Self {
    Self()
  }
}

impl Filter for Videos {
  fn pub mut run(document: mut Document) {
    let nodes = document.nodes.iter_mut.to_array

    loop {
      match nodes.pop {
        case Some(Element(img)) if img.name == 'img' -> {
          let Ok(path) = img.attributes.get('src') else next
          let path = path.to_path
          let tail = path.tail

          # I only care about webm formats for the time being.
          let Some((name, 'webm')) = tail.split_once('.') else next
          let poster = path.directory.join('${name}.poster.jpg').to_string

          img.name = 'video'
          img.attr('controls', 'true').attr('preload', 'none').attr(
            'poster',
            poster,
          )

          let _ = img.attributes.remove('src')
          let _ = img.attributes.remove('alt')

          img.source.attr('src', path.to_string).attr('type', 'video/webm')
        }
        case Some(Element(v)) -> nodes.append(v.nodes.iter_mut.to_array)
        case Some(_) -> {}
        case _ -> break
      }
    }
  }
}
